![карта 128 на 128](https://drive.google.com/uc?export=view&id=106qtsPsopzkFS6pH3Y7LJhC72V79IkJf)

# Анализ примеров
Заменим каждую “.” на красный цвет пикселя, а “#” - на белый.
- При n = 4 и n = 128 (n - размер квадратных карт) карта представляла из себя квадрат, где каждая клетка свободна.




Нужно выводить путь в простых действиях робота на каждой виртуальной секунде (Вверх, вниз, влево, вправо), поэтому для этих тестов достаточно смотреть на Манхэттенское расстояние. 
``` python
def find_route_easy(x0, y0, x1, y1): #input start and end coords
    ans = ''
    if x1 - x0 >= 0:
        ans += 'R' * (x1 - x0)  #go right
    else:
        ans += 'L' * (x0 - x1) #go left
    if y1 - y0 >= 0:
        ans += 'D' * (y1 - y0)  #go down
    else:
        ans += 'U' * (y0 - y1)  #go up
    return ans
```

	
- При n = 180, 384, 1024 карта представляет собой пустые квадратные ячейки, которые связаны между собой дорожками в один пиксель. 

![карта 128 на 128](https://drive.google.com/uc?export=view&id=1GjIhTwYBHyjgpZTT4PAjhFvbcIHRtV9e)

- При n = 1024 карта превращается в карту Иннополиса

![карта Иннополиса](https://drive.google.com/uc?export=view&id=1WsM2_F9elyg59w7ZYDwd77BhPVzZsXQO)

Еесли мы будем стоять в центре квадрата, то мы можем добраться до любого другого центра с помощью приведенного алгоритма выше. Маршрут строится за O(1). Теперь предположим, что заказы и робот могут располагаться не в центре квадратов, тогда опять же мы можем пользоваться алгоритмом выше, так как в пределе одного квадрата заказ достижим. Вот так будут выглядеть перемещения робота:

# Система распределения заказов
Идейно система очень проста: У нас есть словарь точек начал заказов, то есть откуда надо заказ забрать, а в каждой точке лежит очередь концов заказов (куда нужно доставить). Это сделано для того, чтобы брать только самый старый заказ, так как при функции “T” выдается только самый старый заказ в данной точки и доставка реализуется верно (иначе выдаться самый старый заказ, а робот будет думать, что везет в другое место). На каждой итерации перебираем роботов, если он в процессе выполнения заказа, то строим продолжение его маршрута, если он закончит заказ за следующие 60 действий или уже бездействует - то мы ищем ему самый ближайший заказ по сумме пути до взятия заказа + расстояние от пункта приема до выдачи. В процессе была решена проблема, что роботу приходит дальний заказ, через несколько итераций заказ в ту же точку приходит роботу, который находиться ближе, и тот робот, который ближний забирает заказ дальнего и они приезжают не в те места. Это было решено с помощью словарей заблокированных и не заблокированных. Если робот получает заказ в какой-то точек, то заказы из этой точки не могут забирать роботы, пока предыдущий не выполнит заказ. Подбор ближайшего заказа вычисляется с помощью перебора нескольких случайных заказов, точка приема заказа которого в словаре не заблокированных вершин. 

# Оптимизация вывода
Ключевым ускорением стал вывод путей роботов на каждой итерации не отдельно, а для всех ботов одновременно. Это было достигнуто с помощью функции ‘’.join()

# Выбор количества роботов и расположение
После моделирования заказов было выявлено, что нет конкретной функции распределения заказов, они равномерно были раскиданы по всем клеткам. Количество ботов было подобрано в результате максимизации тестирующей системой. 

![Распределение](https://drive.google.com/uc?export=view&id=1u8pISWoy35D1HYJKIJsnwHVX6eLIxyX0)
